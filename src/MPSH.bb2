; -----------------------------------------------------------------------------
;                       ___  _________  _____ _   _ 
;                       |  \/  || ___ \/  ___| | | |
;                       | .  . || |_/ /\ `--.| |_| |
;                       | |\/| ||  __/  `--. \  _  |
;                       | |  | || |    /\__/ / | | |
;                       \_|  |_/\_|    \____/\_| |_/
;                                                   
;                           Mass Produced SHapes                          
; -----------------------------------------------------------------------------
;
; The MPSH file format is pretty simple. It's basically just a header and
; manifest that is prepended at the front of the Blitz Basic "shapes" format,
; the one that's read by LoadShapes.
;
; The manifest allows us to get around a limitation of LoadShapes where it's
; not possible to read arbitrary shapes from the "shapes" file. You will always
; start at the first one and either read them all or read a reduced range.
; It's not possible to read only shapes 4-8, 17, and 24.
;
; The MPSH format (pronounced "impish") seeks to solve that problem.
; The header is 12 byte long and consists of:
; - 4 byte identifier "MPSH"
; - 4 byte version number. This is always 1 for now
; - 4 byte shape count. This lets us know how many shapes to expect.
;
; Following the header is the shape manifest. This is series of 8 byte entries
; that consist of:
; - 4 byte offset. This is the offset from the beginning of the file where the
;                  shape is located (makes for easy file seeks)
; - 4 byte shape size. This is the size of the shape, in bytes.
;
; After the manifest is each shape, including shape header, as you'd find it in
; file generated by Blitz's SaveShapes.
;
; Note that SaveShape and SaveShapes store the images in two separate formats.
;
; There are only 4 methods in this API:
; - MPSH_begin: Called when you want to start using the API. You pass in a 
;               context variable that will be used by the other methods
; - MPSH_end: Called when you're done
; - MPSH_shape_count: Returns the number of shapes in the MPSH file
; - MPSH_get_shape: Loads and prepares one or more shapes.
;
; These methods must be called in `AMIGA` or `QAMIGA` mode.
;
; Example of use:
;
; DEFTYPE .MPSH_context
; MPSH_begin{&context, "people.mpsh"}
; NPrint "Number of shapes: ", MPSH_shape_count{&context}
; MPSH_get_shape{&context, 0, 2, 1}     ; Load #2 to shape id 0
; MPSH_get_shape{&context, 1, 4, 3}     ; Load #4-6 to shape ids 1-3
; MPSH_get_shape{&context, 4, 10, 1}    ; Load #10 to shape id 4
; MPSH_end{&context}
;
; Blit 0, 0, 0 ; Blits shape 0, which is the id #2 in the MPSH file.
; -----------------------------------------------------------------------------

NEWTYPE .MPSH_header
  magic.l
  version.l
  shape_count.l
End NEWTYPE

NEWTYPE .MPSH_entry
  offset.l
  size.l
End NEWTYPE

NEWTYPE .MPSH_context
  shape_count.l
  manifest_ptr.l
  file_id.l
End NEWTYPE

#MPSH_magic = $4D505348 ; MPSH

; Initializes the MPSH context. Must be the first thing to be called.
; While you could call it at any time, it's probably best to call it around when
; you need to read the shapes as it keeps the MPSH file open until MPSH_end is
; closed
;
; Params:
; - context_ptr: pointer to an new .MPSH_context
; - file_path$: path to the MPSH file
Statement MPSH_begin{context_ptr.l, file_path$}
  DEFTYPE .MPSH_context *context
  *context = context_ptr

  If Exists(file_path$) = 0 Then Statement Return

  ; Load the file and read in the 
  DEFTYPE .w file_id
  *context\file_id = 0
  If ReadFile(*context\file_id, file_path$) = 0 Then Statement Return

  FileInput *context\file_id

  ; Read the file header
  DEFTYPE .l magic, version, shape_count
  ReadMem *context\file_id, &magic, SizeOf .l 
  ReadMem *context\file_id, &version, SizeOf .l 
  ReadMem *context\file_id, &shape_count, SizeOf .l 

  !DB_printf{"******** MSPS shape count: %l", shape_count}

  If magic <> #MPSH_magic Then Statement Return

  ; Allocate memory for a manifest
  DEFTYPE .l entry_size

  entry_size = shape_count * SizeOf .MPSH_entry
  *context\manifest_ptr = AllocMem_(entry_size, $10000)
  ReadMem file_id, *context\manifest_ptr, entry_size

  current.l = *context\manifest_ptr
  For i = 0 to shape_count - 1
    !DB_printf{"******** Offset: %ld | Size: %ld", Peek.l (current), Peek.l (current + 4)}
    current + 8
  Next

  ; Store some values for later
  *context\shape_count = shape_count
End Statement

; Closes the MPSH context. Must be called to close the MPSH file and clean up
;
; Params:
; - context_ptr: pointer to an initialized .MPSH_context
Statement MPSH_end{context_ptr.l}
  DEFTYPE .MPSH_context *context
  *context = context_ptr

  FreeMem_ *context\manifest_ptr, *context\shape_count * SizeOf .MPSH_entry
  CloseFile *context\file_id
End Statement

; Used to load the shapes into chip ram
; 
; Params:
; - context_ptr: pointer to an initialized .MPSH_context
; - start_blitz_id: The first id you want the shapes to have
; - shape_id: The id of the shape inside the MPSH file
; - count: The number of sequential shapes you want to load
Statement MPSH_get_shape{context_ptr.l, start_blitz_id.w, shape_id.w, count.w}
  DEFTYPE .MPSH_context *context
  *context = context_ptr

  FileInput *context\file_id

  ; Find the shape
  DEFTYPE .MPSH_entry *entry, *cur_entry
  DEFTYPE .l entry_ptr

  entry_ptr = *context\manifest_ptr + (SizeOf .MPSH_entry * shape_id)
  *entry = entry_ptr

  ; Figure out how much memory it's going to take
  DEFTYPE .l total_size
  total_size = 0
  *cur_entry = entry_ptr
  For s = 0 to count - 1
    total_size + *cur_entry\size
    *cur_entry + SizeOf .MPSH_entry
  Next

  ; Allocate enough memory to read in the shape
  DEFTYPE .l shape_mem
  shape_mem = AllocMem_(total_size, $10000)
  
  ; Find the shape in the file and read it in
  FileSeek *context\file_id, *entry\offset
  ReadMem *context\file_id, shape_mem, total_size

  ; Turn it into a shape
  DecodeShapes start_blitz_id, start_blitz_id + (count - 1), shape_mem

  ; Cleanup
  FreeMem_ shape_mem, *entry\size
End Statement

Function .l MPSH_shape_count{context_ptr.l}
  Function Return Peek.l(context_ptr)
End Function

; =============================================================================
; BitMap 0, 320, 200, 5
; BitMap 1, 320, 200, 5
; LoadPalette 0, "palette.iff"

; DEFTYPE .MPSH_context
; MPSH_begin{&context, "myshapes.mpsh"}

; NPrint "Number of shapes: ", MPSH_shape_count{&context}

; MPSH_get_shape{&context, 0, 2, 1}     ; Load #2 to shape id 0
; MPSH_get_shape{&context, 1, 4, 3}     ; Load #4-6 to shape ids 1-3
; MPSH_get_shape{&context, 4, 10, 1}    ; Load #10 to shape id 4

; MPSH_end{&context}

; InitCopList 0, 44, 200, $10005, 8, 32, 0

; BLITZ
; CreateDisplay 0

; DEFTYPE .w x, y, dx, dy, bmp, shp
; x = 0
; y = 0
; dx = 1
; dy = 1
; bmp = 0
; shp = 0

; Buffer 0, 32000
; Buffer 1, 32000

; Repeat
;   VWait

;   DisplayPalette 0, 0
;   DisplayBitMap 0, bmp
;   bmp = 1 - bmp
;   Use BitMap bmp
;   UnBuffer bmp

;   BBlit bmp, shp, x, y

;   If x = 0 Then dx = 1 : shp + 1
;   If x + ShapeWidth(0) = 320 Then dx = -1 : shp + 1

;   If y = 0 Then dy = 1 : shp + 1
;   If y + ShapeHeight(0) = 200 Then dy = -1 : shp + 1

;   If shp > 4 Then shp = 0

;   x + dx
;   y + dy

; Until RawStatus($45)

; End
